 'cl.exe' is not recognized as an internal or external command
 Hi I'm sure I set /ZI (not /Zi) compile flag but I get cl.exe error with vs 2019.
You need to run blink from the VS command-line or have cl.exe (the C++ compiler) in your PATH.

![image](https://user-images.githubusercontent.com/1736619/82135301-aeb3e280-9833-11ea-9f82-3a327962f185.png)
Same error and the cl is in path.

Right, sorry, that should have been: You need to run the target application from the VS command-line (or use VC++ 2017, which does not suffer from this problem, or hardcode the path as per https://github.com/crosire/blink/issues/31#issuecomment-629704515). It's the same problem as noted in multiple issues: the original compile command-line is no longer written by VC++ 2019, so blink has to fall back to a custom one.

 Include path
 Hello!

I managed to get the example project in #30 running, after having fought with #31, but then ran into one more issue with the include path not seeming to be taken into account by blink.

**Original Program**

From #30.

```cpp
#include <iostream>
#include <windows.h>

void changefunction() {
    static int n = 6;
    // n = 0;
    std::cout << n++ << std::endl;
}


int main(int argc, char** argv) {

    while (true)
    {
        changefunction();
        Sleep(1000);
    }

    return 0;
```

This builds fine, and changing anything in `changefunction` works well. But now look here.

**Changed program**

```cpp
#include <iostream>
#include <windows.h>
#include "cannot_be_found.h"

void changefunction() {
...
```

<br>

### The problem

There are two of them; one making the other harder to spot.

1. blink does not report the error
2. The error being that "cannot_be_found.h".. cannot be found

The error message is sporadic however, I suspect some issue with STDOUT and buffering. Here's what I typically see.

```bash
Detected modification to: C:\Users\marcus\source\repos\ConsoleApplication1\ConsoleApplication1.cpp
ConsoleApplication1.cpp

Finished compiling "C:\Users\marcus\source\repos\ConsoleApplication1\ConsoleApplication1.temp.obj" with code 2.
```

That empty space there appears related to whether or not there's an error. When compilation succeeds, the empty line is replaced with..

```c
Successfully linked object file into executable image.
```

<br>

### The workaround

I found that if I replicate my include path in the environment where blink is called, things appear to work.

```bash
$ set INCLUDE=all;the;things;VS;included
$ blink.exe consoleapplication1.exe
win!
```

Is there another way to cope with this? I couldn't find mention of this anywhere, but I don't see how blink could be used without it?
See https://github.com/crosire/blink/issues/31#issuecomment-629704515. Assuming this is using VC++ 2019, the include paths used to build your project won't be added to the command-line automatically, so this has to be done manually by modifying the line mentioned in the comment.
This can probably be improved by trying to extract the include paths from the PDB (if VC++ 2019 stores them there). VC++ 2017 stored the entire command-line, hence why that was not necessary before.

> This can probably be improved by trying to extract the include paths from the PDB (if VC++ 2019 stores them there). VC++ 2017 stored the entire command-line, hence why that was not necessary before.

Aah, yes that makes sense. Thanks for confirming!

 Support for exceptions
 Hi @crosire,

This isn't a bug report, I just wanted to document that exceptions don't appear to be supported by blink (?)

I'm initially had issues with VS2019 but luckily found #30 which got me half-way there, except the default "Console Application" preset in VS comes with exceptions enabled, which prompts the following error.

```bash
Unresolved external symbol '?uncaught_exception@std@@YA_NXZ'.
```

<details><summary>Full output</summary>

```bash
$ blink.exe ConsoleApplication1.exe
Launching in target application ...
  Entry point was written to address 000001B91B9D0000
Reading PE import directory ...
Reading PE debug info directory ...
  Found program debug database: C:\Users\marcus\source\repos\ConsoleApplication1\x64\Debug\ConsoleApplication1.pdb
  Found source file: C:\Users\marcus\source\repos\ConsoleApplication1\ConsoleApplication1.cpp
Starting compiler process ...
  Started process with PID 14996
Starting file system watcher for 'C:\Users\marcus\source\repos\ConsoleApplication1' ...
Detected modification to: C:\Users\marcus\source\repos\ConsoleApplication1\ConsoleApplication1.cpp
ConsoleApplication1.cpp
Finished compiling "C:\Users\marcus\source\repos\ConsoleApplication1\ConsoleApplication1.temp.obj" with code 0.
Unresolved external symbol '?uncaught_exception@std@@YA_NXZ'.
The target application has exited with code 3221225786.
^C
```

</details>

Initially I suspected that maybe blink needs to be built with exceptions in order to support it, but it already was. Turning off C++ exceptions for the console application solved it.

![image](https://user-images.githubusercontent.com/2152766/81499702-4e69f180-92c5-11ea-8599-16d9d9dc9dc3.png)

Exceptions themselves should not be a problem. But VC++ 2019 (in contrast to 2017) isn't working particularly well out of the box with blink, because of the reason noted in #30. You'll likely have to set up a compiler command-line matching your project here and rebuild blink: https://github.com/crosire/blink/blob/fc5811a9e3b3263932528057baf480982226e675/source/blink.cpp#L386

It all boils down to 2019. Can't make any promises, but I'll see if there's anything I could do to resolve this. Blink has been fantastic so far, despite the minor issues so thanks for that!

 won't work for a simple test.
 environment:
>visual studio 2019
>std:c++latest

code:
```c++
#include <iostream>
#include <windows.h>

void changefunction()
{
    static int n = 0;
    std::cout << n++ << std::endl;
    //std::cout << "add msg" << std::endl;
}
int main(int argc,char** argv)
{

    while (true)
    {
        changefunction();
        Sleep(1000);
    }

    return 0;
}
```
test step:
1. blink.exe "C:\Users\kk\source\repos\ConsoleApplication1\x64\Debug\ConsoleApplication1.exe"
2.  uncomment " //std::cout << "add msg" << std::endl;"
3. save file 
output:
```
Launching in target application ...
  Entry point was written to address 0000024D24CE0000
Reading PE import directory ...
Reading PE debug info directory ...
  Found program debug database: C:\Users\kk\source\repos\ConsoleApplication1\x64\Debug\ConsoleApplication1.pdb
  Found source file: C:\Users\kk\source\repos\ConsoleApplication1\ConsoleApplication1.cpp
Starting compiler process ...
  Started process with PID 10532
Starting file system watcher for 'C:\Users\kk\source\repos\ConsoleApplication1' ...
Detected modification to: C:\Users\kk\source\repos\ConsoleApplication1\ConsoleApplication1.cpp
ConsoleApplication1.cpp

Finished compiling "C:\Users\kk\source\repos\ConsoleApplication1\ConsoleApplication1.temp.obj" with code 2.
```
program output:
```
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
```
nothing changed here, is there any steps wrong?

Visual C++ 2019 unfortunately does not seem to write the target command-line to the OBJ file anymore, so blink cannot reconstruct it and falls back to the default. For that to work you need to run blink from within a Visual Studio developer command prompt (set up with the correct toolset, so e.g. use the "x64 Native Tools Command Prompt for VS 2019" for x64 applications) so that it can find the compiler.
With that + the two latest commits that fix some things I can run your example and it works.

thanks a lot.
it works now with "x64 Native Tools Command Prompt for VS 2019" .


![image](https://user-images.githubusercontent.com/21139416/70745826-f7b3b800-1d24-11ea-84ae-de6222be5049.png)


@crosire Same problem here, last version visual studio, last blink with the last commit but still the error occur + i have no details about the error from cl.exe 

 Fixed some problems where object files could not be located
 Thanks for sharing the blink project!

I tried to use the dll branch with our code base and found two issues: 
  1. When `read_debug_info` is called for multiple modules, the list of object files and the list of source files get out-of-sync; object files are correctly appended to the array, but source files overwrite existing entries.
  2. I encountered the case, that the object file paths are not absolute in the PDB file, I fixed this by looking at the current working directory in the code view records.

With these fixes blink is able to find all source and object files in our solution, which has multiple projects and a kind of unusual file structure.

This pull request also adds a little feature with lets you attach to a running executable by its name - instead of looking up the PID manually. I added the command line switch `-a` so that it does not interfere with the existing command line options.
Looks good, thank you!

 cl.exe not found
 Hi,

I've built a simple hello world application with /Zi and VS 17 community edition version 15.8.7 with an x64 build of the 19.00.24234.1 compiler.

I got an error saying it couldn't find cl.exe. Hard coding cl.exe to the correct path then gives the error: Cannot open include file 'windows.h'. I'd rather not have to mess around with vcvarsall.bat... 

Any ideas why this seems to work for other people but not on my machine? Thanks.
Compile your application with `/ZI`. Blink will not be able to deduce the build command-line if compiled with just `/Zi`.

Cool, thanks. It does successfully link now but weirdly it doesn't do anything.

```
#include <Windows.h>
#include <iostream>

int main()
{
    while (true)
    {
        std::cout << "hello" << std::endl;
        Sleep(100);
    }
}
```

After changing "hello" to "hello world" it continues to print "hello" after linking, instead of the new string.

Please read the readme. Both things you asked so far are answered there 
See https://github.com/crosire/blink/issues/14#issuecomment-450225844

Got it now, thank you.

You are absolutely right but perhaps these points could be made more explicit? I did read the readme multiple times and still missed it ( /Zi is very similar to /ZI and the importance of having a function being called multiple times is easy to understate )

Fair enough. Made some changes to highlight these two things.

 Actually check the ClassID inside the COFF header
 The actual signature of an extended COFF is on 3 fields :

Machine type 		-> IMAGE_FILE_MACHINE_UNKNOWN (0)
Number of Sections 	-> FFFF
Class ID		-> {D1BAA1C7-BAEE-4ba9-AF20-FAF66AA4DCB8}

This patch adds the missing check of the Class ID inside the "is_extended" function.

For matter of simplicity, I've filed in the 16 byte array as a static
constant inside the header. The actual value of the classid is only
documented in comments, but there's no pre-filled structure containing it.

Now we can be assured to have a robust way of checking for an extended COFF file.
 Update README after changes made in #23 and #25
 
 Make Blink compatible with object files built with `/bigobj`
 See discussion in issue #23 

Do not merge yet : 

If things are going to get built with /bigobj too. The code that does the "linking and patching" needs a similar modification.

Probably around here : https://github.com/crosire/blink/blob/master/source/blink_linker.cpp#L136
update : So, the changes mentioned in the first message are done, but there's still a crash occuring here: https://github.com/crosire/blink/blob/master/source/blink_linker.cpp#L349

(the section referenced by the symbol has a number way higher than the number of section in the object file - causing to be out of the range in side the vector)

I need to dig a bit more about what's going on right there. 

@crosire This thing is ready for you to checkout ;-) 

Fix #23 

Thank you. Great job figuring this out! 
I'm not a big fan of virtual functions/dynamic casting/exceptions though, so decided to implement this slightly differently with templates only. Hope you don't mind. Commit is below:

@crosire I think I said it was a quick and dirty one, and I'm pretty happy that you used that as the basis for fixing what happens with "bigobj" coff files.
I'm going to check if everything works on my end with the commit in question :wink:

 Add CMakeLists.txt file
 I had some issues with the included Visual Studio solution. It was not finding "Windows.h" directly when opened on my system. Re-targeting the windows SDK was necessary, but then it stopped to work again 🤷‍♂️.

CMake is able to generate a Visual Studio solution that is specific to the user's installation of Visual Studio and of the Windows SDK. It is much more flexible.

This PR just adds a CMakeLists.txt file in the root directory that permits to build blink.exe via CMake. This also facilitate automating the build of the project (can just script 2 lines of bash that does CMake -G"Visual Studio  15 2017 win64" . and "CMake --build ." (useful for like, Continuous Integration... 😄 )


 blink.exe crash when editing program built with the /bigobj flag
 I just found out about this project and it looks really interesting. 😃 

I'm trying to see if I can edit code from a little game engine project I have and see the result right away with blink.

The target program is built in Debug mode. 

I attach blink.exe to the program by giving it the PID.

When I modify a file, I have a debug assertion triggered inside vector's `operator()`. 

This occurs in `blink::application::build_compile_command_line()` when creating 
`			std::vector<char> debug_data(section->SizeOfRawData);`

`section` here is an iterator returned by the std::find_if function that seems to look for a section of the name `.debug$S` but doesn't find it.

The value of the iterator is never checked before de-referencing it.

I'm currently trying to understand why my program doesn't have a "debug" section here, but I really feel like the following code should only be executed after testing `section != sections.end()` to check if it was found... 🤔 
(It seems that this function in blink just returns an empty string when an error is found. I'm going to add an additional check before attempting to use the `section`)

Looking at the log, it does find all the necessary source files and everything, and it watches for the modifications. But when you save your changes to the file, it seems it tries to invoke the compiler (cl.exe) but doesn't find it:
```
Starting file system watcher for 'e:\git\sdl_base' ...
Detected modification to: e:\git\sdl_base\build\enc_temp_folder\dea695625b187ed511a9541fdb327a1\application.cpp
'cl.exe' is not recognized as an internal or external command,
operable program or batch file. <--- I suppose here lies the issue
Finished compiling "e:\git\sdl_base\build\enc_temp_folder\dea695625b187ed511a9541fdb327a1\application.temp.obj" with code 9009.
Detected modification to: e:\git\sdl_base\src\application.cpp
```

Okay, launching blink.exe from the Visual Studio developer command prompt (a place where cl.exe is in the path) doesn't resolve the issue. 

blink mainly becomes useful if it can automatically deduce the compile command-line from the input object files. The default command-line does not have any SDK paths or defines set, so would most likely fail to compile regardless of whether cl.exe is in your PATH or not. You'd have to manually change the fallback command-line in source code to suit your specific application.

So the real issue here is finding out why your object files do not have a `.debug$S` section. This should be standard when compiling with debug symbols enabled (`/Zi` or `/ZI`). It is however missing when compiling with `/Z7` so make sure you use one of the other two!! See also https://github.com/crosire/blink/issues/6#issuecomment-470308259.

Hi, the project is built with the standard configuration for "Debug" (as generated by CMake) and /Zi is enabled

So, I'm trying to understand the problem, here's the raw output of dumpbin on the .obj file associated with the changed source file 

```
e:\git\sdl_base\build\test_project_exe.dir\Debug>dumpbin application.obj
Microsoft (R) COFF/PE Dumper Version 14.16.27027.1
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file application.obj

File Type: EXTENDED COFF OBJECT

  Summary

          38 .CRT$XCU
          75 .bss
       17D50 .chks64
         CAD .data$r
       F7B94 .debug$S
          58 .debug$T
          F6 .drectve
        83B8 .pdata
        E8DD .rdata
        154C .rdata$r
           8 .rtc$IMZ
           8 .rtc$TMZ
         194 .text$di
       42D71 .text$mn
        4F73 .text$x
          27 .text$yd
        B468 .xdata
         288 .xdata$x

e:\git\sdl_base\build\test_project_exe.dir\Debug>
```

Seems there's a .debug$S section in this .obj file 🤔 

So, I set a breakpoint in blink.cpp while debugging my program (after blink did it's little process injection thing)

This is clearly the file being opened at this point : 
![image](https://user-images.githubusercontent.com/1816251/54784892-3482d080-4c25-11e9-8161-956ac6947b51.png)

While stepping through with the debugger, when reading the number of section after the first call to `ReadFile`, the number of section in the header is set to `0xffff` this doesn't seem normal...

I'm suspecting it's not reading the object file properly at this point. If I have any more info, I'll post here. If somehow I fix it myself, I'll PR.

Do you have any idea why it is not picking up the sections in the file properly?



okay so, the file is indeed read properly (this would be strange) 
![image](https://user-images.githubusercontent.com/1816251/54787230-5d0dc900-4c2b-11e9-845a-4c481bc8e813.png)

Maybe that object file is not of the right format? 

Now that I think about it, the project is linking to some pretty big header only libraries (ChaiScript, GLM) in some of it's compilation units, and I had to add the `/bigobj` to my build options. Reading MSDN, this increase the possible number of sections in the file to a 32bit value. So, what's probably happening here is that blink is not reading the header properly because... Well, it's not a normal COFF header anyway...! 😮 

________
**update** when a symbol has been built with /bigobj, the header is an extended one. the Win32 API has a structure called `ANON_OBJECT_HEADER_BIGOBJ` that has the correct layout. I need to confirm this, but it's possible to test the difference by checking in the header (read normally) if the machine type is `0x0000` and the number of sections is `0xFFFF`.

Gonna do some more testing, but I feel like I'm onto something

_____
**update 2** I have a patch where now it finds and read correctly the `.debug$S` section from the file, I'm going to pull request it soon. 

Now I'm facing another issue where it is not finding the compiler command line inside the section.

using dumpbin, it seems that the strings "cdw" or "cl." or "-Zi" aren't present in this section of the object file.

Doing a full dump, *nowhere* in that file you can find these strings either. 

Correct me if I'm wrong, but shoudln't I be able to find the compilation command of an object file if it has been build with `/Zi` ?

it seems that the compilation command is stored in the object file only with `/ZI` , not with `/Zi` in this specific case

Nice findings! Yeah, it seems like the command-line is only stored with `/ZI` after all (kinda makes sense given what that option is meant for). It used to be that this information was stored in the PDB file itself, but that was dropped with current Visual C++ versions. So for now the only automatic way to gather information about how to compile the input files is with `/ZI`. Bit unfortunate considering that the rest of blink should work with the other PDB options too.

Yes. Now I'm currently trying to fix the linker for this usecase in #25. Right now it's crashing because some symbol somewhere is reffering to a section number that is way higher that the actual number of sections in the object file...

update: It seems that I4m still reading garbage inside the link() function when reading the symblols table, despite using the correct `PointerToSymbolTable` value, but I'm having trouble getting VisualStudio's debugger to cooperate right now ;-)

So, the first symbol seems to be read mostly properly, at least it has the correct name. So I now suspect that in this non-normal COFF file format, we need another struct than "IMAGE_SYMBOL" too. 

The problem is, the documentation from microsoft on this is praticularly lacking. Somone even complained about this on the microsoft forums... xD
https://developercommunity.visualstudio.com/idea/408610/pecoff-format-specification-issues.html

And the help about the `/bigobj` compiler flag only mention that it permits to have more sections and symbols in object files.

So I'm mostly going blind on this, but since it's *so close* to work, I'm not going to stop there...

Okay, so in the one symbol that has the right name, both it's section number and type are at 0xFFFF. I need to find the "modified" version of the header that matches this, somewhere.

While I try to piece the differences together by reading header files and "trying stuff", I left some feedback to Microsoft because the exact effect of this compiler switch are poorly documented, and the documentation about the COFF file format is lacking. https://github.com/MicrosoftDocs/cpp-docs/issues/873

found that there's a `IMAGE_SYMBOL_EX`. It's a bigger sutrcutre. It's probably what I was looking for. I can't find much documentation about it, but it uses a LONG for the section number instead of a SHORT, so it *has* to be this. 

I need to do some refactor of the linker code to be able to use this... 😓 

I fixed it for bigobj. (see #25)

There's 2 things that changes when object files are "big" objects files : 

1 - the COFF header is an extended version
2 - Each symbols uses an extended version that occupies more than the 18 bytes of the regular one.

What I did is that I refactored the "link" function past the problematic point to some templated things around the type of the symbol records.

All of the reallocation logic is the same.

 Function to sync patching time
 First if all, I like this project a lot. I have been testing for two weeks against live++, and I like your approach when no changes are made to the program, it is very convenient, but there are moments when patching seems occurs at the moment of program execution and the program crashes. 

Maybe you could add some agreement concerning the name of a certain global static function (___sync or something like that) which you can hook and make patching only when there is a call to this function.
if such a function is not found in the program, then run patching at any time as original behavior

And I would also like to have a global callback that would be called upon successful patching, but in any case, it can be combined with the sync function if it can return a bool.

Thank you!

This is now implemented. The following is an example how this can be used to synchronize blink with some other place in your code:
```c++
#include <mutex>
#include <condition_variable>
std::mutex blink_mutex;
std::condition_variable blink_cv;
bool blink_wants_to_work = false;

extern "C" void __blink_sync(const char *source_file)
{
	std::unique_lock<std::mutex> lock(blink_mutex);
	blink_wants_to_work = true;
	blink_cv.wait(lock); // Wait for app to allow us to continue
}
extern "C" void __blink_release(const char *source_file, bool success)
{
	blink_wants_to_work = false;
	blink_cv.notify_one(); // Signal app thread that it may continue
}

// Somewhere else in your code where it is safe for blink to execute
{
	std::unique_lock<std::mutex> lock(blink_mutex);
	if (blink_wants_to_work)
	{
		blink_cv.notify_one(); // Notify "__blink_sync" to continue
		blink_cv.wait(lock); // Wait for "__blink_release" to allow continuation
	}
}
```

 compiler error messages not displayed
 When #20 occurred I didn't get any error messages, even when commenting out the "Only print error information" if @ blink.cpp:283

Maybe it should keep stderr separate from stdout and always print it instead of merging and parsing?
That might also fix another usability issue: if you compile without /ZI and blink is run from a normal cmd (not VS dev) it can't find cl.exe but no error message is displayed ("cl.exe is not recognized...")
I'm not able to reproduce that. If I run a small test app with PCH I get this output in the blink console:
```
...
Starting file system watcher for 'c:\projects\blink-test\source' ...
Detected modification to: c:\projects\blink-test\source\main.cpp
c:\projects\blink-test\source\main.cpp(1): error C2855: command-line option '/Z7' inconsistent with precompiled header
Finished compiling "c:\projects\blink-test\source\main.temp.obj" with code 2.
```
cl.exe also doesn't print errors to stderr for me, they all go to stdout (verified via `cl.exe ... 2> errors.log`). So it doesn't look like printing stderr would help here.

> Detected modification to: c:\projects\blink-test\source\main.cpp
> c:\projects\blink-test\source\main.cpp(1): error C2855: command-line option '/Z7' inconsistent with precompiled header

That's odd. I tried again, it worked the first time but then not anymore, I only get:
```
Detected modification to: test.cpp
test.cpp

compile complete 2
```

> cl.exe also doesn't print errors to stderr for me

Then it must be gcc doing that.

 not compatible with PCH
 because it removes /ZI? At least cl was called without any /Z* debug option

error C2855: commandline option '/Z7' inconsistent with precompiled header
PCH is a bit of an issue. Information about the compiled PCH is stored in the application PDB, but it can't be specified on the command-line or else the compiler will attempt to modify it, which won't work while the application is running. blink could copy it to a temporary location and specify that path to workaround this. But what then what happens if the user decides to modify the file generating the PCH? All future compiles would now reference the old PCH data from the application PDB, which no longer makes sense.

Yeah quite tricky, you could also try to disable PCH but most code out there probably does not compile both ways.

By the way what I tested was the Win32 (GUI) sample project VS generates. That uses PCH by default.

@crosire It would be great if this limitation was advertised on the readme. Too bad it won't work, I was excited to try this out on my project!

blink should still work, it will just take longer to compile a change, since it cannot make use of PCH data.

It looks like it gets setup fine, but then once I make a code change (in this case to main.cpp) I get the following output:

```
Detected modification to: C:\Code\Flex\Flex\FlexEngine\src\main.cpp
main.cpp
C:\Code\Flex\Flex\FlexEngine\src\main.cpp(1): fatal error C1083: Cannot open include file: 'stdafx.hpp': No such file or directory
Finished compiling "C:\Code\Flex\Flex\FlexEngine\src\main.temp.obj" with code 2.
```

I'm compiling with /ZI, are there any other flags which are necessary? (Edit and Continue for example?)

See https://github.com/crosire/blink/issues/32#issuecomment-629705124

 header file changes
 How does it handle header file changes?
I guess it's not possible figure out which source files are affected.
It doesn't currently. It would be possible to figure out all the source files affected in theory (that information is stored in the PDB and blink already reads that, it just doesn't do anything with it right now).

See the following (this list also contains header files, but blink currently filters it for *.cpp files only):
https://github.com/crosire/blink/blob/55f2534f1933af0c70eeab5ce106fb888e51c0cc/source/blink.cpp#L131

Maybe it should output a warning at least that the change was detected and the project is now in a floating state.

> It would be possible to figure out all the source files affected in theory (that information is stored in the PDB

It is? Isn't that an awful lot of data? Or does it filter system includes out?

Nope, they are all in. It is a lot of data.

Proof of concept is in the `headers` branch. It will compile all source files which include the modified header file.

 comparison with "edit and continue"
 How does it compare to /ZI?
Implementation details, performance, limitations.
Would be good to add that to the readme.
About EnC limitations: https://blogs.msdn.microsoft.com/vcblog/2016/07/01/c-edit-and-continue-in-visual-studio-2015-update-3/

Requires /Gy + /INCREMENTAL and is incompatible with /OPT:* and custom compilers.

Technically blink makes use of a lot of the information provided by `/ZI`. So there are silimarities. But this projected started back when EnC was still much more limited (it improved a lot in the last couple of years). I haven't compared in a while.
On the points you mentioned: blink doesn't need `/Gm` or `/INCREMENTAL`. It also works with optimizations enabled (although this could potentially cause some weird behavior because of inlining).
blink will attempt to use whatever compiler was used to compile the target application. If it fails to detect that it will instead fall back to executing the first cl.exe that is in PATH.

I guess it's still true that EnC uses extra padding to replace functions "in-place" in contrast to your approach of putting them in new memory and redirecting the old ones?

 Question about relocations and static local variables
 Hi.
Suppose we have this `StaticVar.cpp` file:
```cpp
#include <cstdio>

static int localStaticVar = 10;

void printAndIncrement()
{
    printf("%d", localStaticVar++);
}
```
We're calling `printAndIncrement` each frame. We want to reload this file for some reason. We're expecting to get this output:
```
10
11
12
13
CODE RELOAD
14
15
...
```
On linux we cannot use relocation data from the `StaticVar.cpp.o` because such a relocations are 32-bit (probably compiler takes into account the "locality" of `localStaticVar` relative to `printAndIncrement`), and in general we cannot insert the address of old `localStaticVar` into the new version of `printAndIncrement`. How blink deal with such cases?
Thank you!
Hello! Take a look at #12 

There's code that successfully finds local static variable usages in reloaded object file (it's mentioned in #12), but currently this code changes such usages for incorrect addresses.

Hey! Thank you, I've read that issue, but my question is more about this.
Suppose we have a `GetAndIncrement.cpp` file:
```cpp
static int localStaticVariable = 0;

int getAndIncrement()
{
    return localStaticVariable++;
}
```
If we compile it to the object file, we will have smth like this:
![getandincrement](https://user-images.githubusercontent.com/9406025/51073508-057b3c00-1683-11e9-888c-b1e133ab3a22.png)
Take a look at `mov` instruction at `0x08000044`. Second operand is the address of the `localStaticVariable` which will be filled by the linker when relocations (on linux it is `R_X86_64_32S`) will be applied.
Then we're touching this file, recompiling, linking it into .dll, loading and fixing the address of the `localStaticVariable` in the .dll in a way where new `getAndIncrement` function will use old version of `localStaticVariable`, exactly what you're talking about in #12.
The problem here is second operand of `mov` instruction is relative 32-bit address of `localStaticVariable`, but since this variable lives in the executable and `getAndIncrement` function lives in the .dll, probably the distance between them in the memory will be way more than a 32-bit number.
So the question is - is there any guarantee on windows that second operand of `mov` instruction in this case is 64-bit address?

blink handles this by allocating the memory region for the new object file sections as close as possible to the existing code in memory. This way the relative offset should still fit into a 32-bit value. Windows has APIs to allocate memory at a specific virtual address which allow this: https://github.com/crosire/blink/blob/55f2534f1933af0c70eeab5ce106fb888e51c0cc/source/blink_linker.cpp#L40 https://github.com/crosire/blink/blob/55f2534f1933af0c70eeab5ce106fb888e51c0cc/source/blink_linker.cpp#L199

I see, thank you very much!

 Troubleshooting target program crash
 Hey, thanks for this great library! I am having trouble making it work though.
Here is what I tried:
 - get the blink repo
 - build blink x64 Debug (Microsoft (R) C/C++ Optimizing Compiler Version 19.16.27012.6 for x64)
 - create target directory & cd there
 - create test.cpp with:
```
#include <iostream>
void fn();
int main() {
	while (true) {
		fn();
	}
}

using std::cout; using std::endl;
void fn() {
	cout << "Hello World" << endl;
}
```
 - compile test.cpp in a VS console with `cl.exe /Z7 /Od /MDd /nologo /EHsc /std:c++latest test.cpp`
 - cd back to blink root
 - launch blink with test.exe (`bin\x64\Debug\blink.exe target\test.exe`) in VS console
output: 
Launching in target application ...
  Entry point was written to address 000000013F1A0000
Reading PE import directory ...
Reading PE debug info directory ...
  Found program debug database: C:\dev\blink\target\test.pdb
  Found source file: c:\dev\blink\target\test.cpp
Starting compiler process ...
  Started process with PID 31796
Starting file system watcher for 'c:\dev\blink\target' ...
  - change output string in test.cpp to something else & save
output:
Detected modification to: c:\dev\blink\target\test.cpp
Finished compiling "c:\dev\blink\target\test.obj" with code 0.
Successfully linked object file into executable image.
Detected modification to: c:\dev\blink\target\test.cpp
The target application has exited with code 3221225501.
  - the test.exe program crashes

  - the additional change in blink was that I disabled commandline detection from the .obj file, as that didn't work, so the commandline used to build is the built-in (as described in #13)
Use `/ZI` instead of `/Z7` for command-line detection. I'll look into the crash, seems to be some CRT state getting corrupted.

Is /ZI required or could the implied /FC be enough?

`/FC` has no impact on the debug data stored in the object files (it only affects display in the command-line output), and that's what blink needs to determine the compiler command-line. So for that to work `/ZI` is required.

 support CMake
 Hello, maybe instead of sln, you should support CMake so that you can build for different studios?

I can create pull request

Thanks
Currently the code doesn't compile with anything older than VS2017, since it uses C++17, so not sure if that would be that useful?

Coming soon VS2019. And maybe it will simplify the assembly of this project as a third-party library or tools.

Closing as this project is currently too specific to VS2017 for it to make sense to support other compilers via CMake.

 How to get it to work?
 Thanks for your great work first!
I try blink with the "example_glfw_opengl3" project from ImGui examples. But it can't work.

All code and project of blink and imgui examples are clone from github repo just now and I didn't change anything. I use VS2017 with Windows SDK Version 10.0.17763.0 on Windows10. I did the following steps:

s1 Build example_glfw_opengl3 Debug|Win32.
s2 Build blink Debug|x86 and copy blink.exe into "imgui\examples\example_glfw_opengl3\Debug" directory.
s3 Open windows's cmd console and enter "imgui\examples\example_glfw_opengl3\Debug" where the example_glfw_opengl3.exe is in.
s4 Invoke "blink example_glfw_opengl3.exe" in the console. example_glfw_opengl3.exe got to run.

`
D:\lab\imgui\examples\example_glfw_opengl3\Debug>blink example_glfw_opengl3.exe
Launching in target application ...
  Entry point was written to address 07B30000
Reading PE import directory ...
Reading PE debug info directory ...
  Found program debug database: D:\lab\imgui\examples\example_glfw_opengl3\Debug\example_glfw_opengl3.pdb
  Found source file: d:\lab\imgui\examples\example_glfw_opengl3\main.cpp
  Found source file: d:\lab\imgui\examples\imgui_impl_opengl3.cpp
  Found source file: d:\lab\imgui\examples\imgui_impl_glfw.cpp
  Found source file: d:\lab\imgui\imgui_widgets.cpp
  Found source file: d:\lab\imgui\imgui_draw.cpp
  Found source file: d:\lab\imgui\imgui_demo.cpp
  Found source file: d:\lab\imgui\imgui.cpp
Starting compiler process ...
  Started process with PID 137948
Starting file system watcher for 'd:\lab\imgui' ...
`

Yes, as you see, everything seems to be right.

s5 When I modify some code in main.cpp of example_glfw_opengl3, such as I modify "ImGui::Begin("Hello, world!");" to be "ImGui::Begin("Hello, blink!");", I get the console log info in console:

`Detected modification to: d:\lab\imgui\examples\example_glfw_opengl3\main.cpp
Finished compiling "d:\lab\imgui\examples\example_glfw_opengl3\main.obj" with code 0.
Successfully linked object file into executable image.`

Everything seems to be right too. But the result could be seen in ImGUI rendering window.
I also try run blink in VS debug mode and set the working directory and Command Arguments to point to imgui_impl_opengl3.

The function or method you're changing must be executed repeatedly, because it will be "changed" only when you enter it the next time. You're stuck in original `main` function. You can change it like that:
```
void update()
{
    ...
    ImGui::Begin("Hello, world!");
    ...
}

int main(int, char**)
{
    ...
    // Main loop
    while (!glfwWindowShouldClose(window))
    {
        update();
    }
    ...
}
```

Yes, of course. I know it. But it not works yet. This is the sample codes(from official example "example_glfw_opengl3/main.cpp" with my little modify) :
```
...
   // Main loop
    while (!glfwWindowShouldClose(window))
    {
            ...
            ImGui::Begin("Hello, world!");
            ImGui::Begin("Hello, blink!");
            ...
    }
...

```




Thank you for your quick reply.

You are misunderstanding things. blink causes a change you do to a function to become effective the next time the function is called. The `main` function is only called once at application startup and then not again. So any changes inside the `main` function won't be visible. For changes to become visible you have to do them in a function that is actually called repeatedly. As was explained above this can be achieved by doing the following:
```c++
void update() // Do changes inside this function
{
    glfwPollEvents();

    // Start the Dear ImGui frame
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();
    ...
    ImGui::Begin("Hello, world!");
    ...
    glfwSwapBuffers(window);
}

int main(int, char**)
{
    ...
    // Main loop
    while (!glfwWindowShouldClose(window))
    {
        update(); // This function is now called repeatedly, so changes get visible the next time it is called after blink has loaded your changes
    }
    ...
}
```
This is usually the case in applications. There are rare cases in which all code is inside the `main` function, those samples being one of those cases.

I get the key point. It works and very cool!
Thank you very much.

Makes me wonder how it deals with inlining and/or changes to header files.

 Duplicate file modification notifications
 Adding this issue here for tracking: Depending on which editor is used to edit a source code file, upon saving the file is often modified multiple times so that the ReadDirectoryChangedW API will report multiple notifications for the same file. This causes blink to compile the file multiple times, which is unoptimal and slows it down. blink should try and detect when a file notification is a duplicate and ignore those.
Potentially related: I'm running blink from VS2017 and it's opening up _gvim_ twice when I make a change in my own project I was to hotload in VS20**13**.  I would expect it to at least trigger VS2013 instead of gvim, but gvim is set as my default editor in windows.

I can't tell if that's why the changes aren't being applied to my exe at runtime, or if I'm doing something wrong either, but so long as I change a few things in `blink::application::link`, the compile completes without error: https://gist.github.com/tankorsmash/18738bec184a68f1f9aa22e3910dd540

I am running a slightly tweaked version of blink to try and run it on vs2017: https://gist.github.com/tankorsmash/94c5627af27ccf786a18017275481394, using tweaks I made just to get it to compile.

It shouldn't open any text editor, but invoke the compiler. There should also be a message saying "Successfully linked object file into executable image" after compilation finished, so it's not compiling anything for you. I suspect that VS2013 stores some debug data differently in the PDB/OBJ files and as such blink is not able to extract the correct compiler commandline here: https://github.com/crosire/blink/blob/171d683a3f88d85f3be7e4ffdda9069922ec2458/source/blink.cpp#L344
I only ever tested with VS2017.

You can try and comment out the true statement of the if in mentioned location and use the pre-defined command line instead (the false statement of that if). Provided that you run blink in a VS2013 developer command line so that the correct cl.exe is used. This has the disadvantage that preprocessor definitions and include directories are not automatically deduced, so you'll have to add them there manually (via additional `/D MY_DEFINE` and `/I "\path\to\include\dir"` arguments added to the `cmdline` string).

Alternativly switch your project to VS2017 if that is reasonable for you =).

I'm running Blink through VS2017, with those modifications. I guess the WindowsTargetPlatformVersion I didn't upgrade too has the breaking changes you use for std::filesystem, but I'm not clear on any of the details there, you'd think it would work fine. I might have VS2017 working in some sort of compatible mode for VS2013.

I am trying to work through the parse_code_view_records bit, but when I place a breakpoint, there without codechanges, blink.exe either kills the exe I'm running, or stops blink.exe altogether.

I'll try to mess around with the code without debugging like you suggest and see if that helps. I tried running my project in 2017 too but it doesn't appear to be a trivial upgrade. Vs2017  does seem very nice compared to 2013 though!

edit: I think the issue with the debugging must be because of the 2013/17 difference. I can put a break in blink's main.cpp but not anywhere after it hooks into my exe. I am going to stop trying to get this working because if even VS messes this up, there has to be some deeper issues with the 2013/2017 translations that would be avoided if I just compiled my exe in 2017. Thank you for offering potential fixes! Take care!

I too have started messing around with this; opening of the text editor happens because blink couldn't read the commandline to compile with from the debug info, and so it incorrectly assembles the "compilation" commandline as just the path to the source, which triggers the opening of the text editor.

 Dependent libraries and static storage duration data
 Blink is amazing, but I can see a couple issues right now:

1. **Linked libraries.** Many projects are designed in a modular way: executable and a bunch of libraries linked to it. Currently blink works only with compilation units linked directly to the executable;

2. **Static storage duration data.** After the first hot reload addresses of static variables are changed, and these variables seem contain zero-initialized data. Would be nice if these variables keep the old addresses. Currently I have no idea how to resolve this issue;

3. Sometimes blink and executable, blink is connected to, **hang** with the following message in terminal:
```Finished compiling "c:\my_project\source\foo.obj" with code 0.```
I'm trying to find the cause, but no success yet.

I'm working on these when I have some free time, so if you have any ideas, please, let me know.
On 1: Jup (see also #8). This would require going through the import address table (which blink already does anyway) and load all the PDBs for imported libraries too, instead of just the application one (to extend the symbol list and source/object file name lists to contain information about the libraries too). The rest should work as it is.

On 2: The relevant code is here: https://github.com/crosire/blink/blob/171d683a3f88d85f3be7e4ffdda9069922ec2458/source/blink_linker.cpp#L360
This is where blink connects addresses of old static variables with the new code. The `.bss` section contains zero-initialized variables and the `.data` section should contain all other global variables. So technically blink should already keep the old addresses and I remember this working in the past. Could you give an example of where the address is no longer the same after reloading?

On 3: This is when `application::link` is invoked. There is a lot happening in there. And it does suspend all threads in the application for the duration of the function to avoid race conditions while blink links in the new code: https://github.com/crosire/blink/blob/171d683a3f88d85f3be7e4ffdda9069922ec2458/source/blink_linker.cpp#L125
Depending on how long that takes, this will be noticeable with a hang. Adding some performance timers in `application::link` should help narrowing down which part takes the longest time. My guess is symbol resolving, but could also be file IO while the object file is read into memory.

2. I can reproduce it with this code:
```
#include <stdio.h>
#include <windows.h>

void print_message() {
	static int test = 0;
	printf("%d %I64u\n", test++, reinterpret_cast<uintptr_t>(&test));
}

int main(int argc, char* argv[]) {
	while (true) {
		print_message();
		Sleep(100);
	}
	return 0;
}
```
Once I change the message I see:
```
100 140695734960484
101 140695734960484
102 140695734960484
0 140695735043080!
1 140695735043080!
2 140695735043080!
3 140695735043080!
```
3. I should have clarified that. I mean it hangs forever.

So yea, 2 happens only the very first time because `_symbols` is filled from PDB file and it seems like static variables are not there (checked it with `cvdump`). Later on it is added to `_symbols` with the new value from updated OBJ file, which is not valid. It seems like we should process OBJ at the very beginning. (When I say "later on" I mean #13, haha)

 Delete *.obj files after linking, always produce source directory from common source path
 Hello! I find these changes useful for me.

It would be also really great if blink can see sources of linked libraries.
 Failed to start file system watcher
 Hello!

I have tried to run blink on a couple projects, but every time I get the same error:

```
Launching in target application ...
  Entry point was written to address 0123456789ABCDEF
Reading PE import directory ...
Reading PE debug info directory ...
  Found program debug database: C:\my_project\_build\my_project.pdb
  Found source file: c:\my_project\foo.cpp
  Found source file: c:\my_project\bar.cpp
  Found source file: c:\my_project\main.cpp
Starting compiler process ...
  Started process with PID 123
Starting file system watcher for '' ...
  Error: Could not open directory handle.
The target application has exited with code 259.
```

I debugged blink for a couple minutes and found out that in method `blink::pdb_reader::read_link_info` variable `stream` has size of 0. The item `pdb_reader::_named_streams["/LinkInfo"]` exists and is equal to 5. `msf_reader::_streams[5].page_indices` is an empty vector.

Is there some compilation/linkage flag I'm missing?

I'm using MSVC 2017, version 15.7.5.

I haven't come across a MSVC 2017 PDB without the link info stream yet, so not sure what would cause that to be missing. But I'll add some fallback code that extracts the project directory from the source code file names again if it isn't found.

When I open the PDB file in hex editor I can see `/LinkInfo` there.

![1](https://user-images.githubusercontent.com/1521057/50446577-a8fbeb00-0926-11e9-9b8c-166c81724d59.PNG)

Now the file system watcher works well, but obj file is not created and `Failed to open input file.` message is printed.

`build_compile_command_line` returns `"c:\my_project\foo.cpp" /Fo"c:\my_project\foo.obj"` when I change `foo.cpp`. Condition `tag != 0x113d` is never false in `parse_code_view_records`'s lambda.

I will create a minimal working sample in a couple hours if it can help.

I solved my problem. The `/ZI` flag is required for blink to work. Otherwise .obj files don't contain required tag.

Your tool works like a charm! Thank you!

 help
 is there any special setup required? I'm not able to get it to reload, although the command line outputs:
```
Detected modification to: E:\imgui\examples\example_win32_directx11\main.cpp
Finished compiling "E:\imgui\examples\example_win32_directx11\main.obj" with code 0.
Successfully linked object file into executable image.
```
my setup:
- Windows 10
- VS2017
- target app: DearImGUI examples.
figured out. don't worry about it.

 dlls
 does this work with dlls that are injected (i'm assuming probably yes because of the ability to attach to running projects, but I'm not sure).
It does not work on code for which there are no symbols in the application PDB. These are used to determine function addresses etc. in the loaded image, so are a hard requirement.

blink does not currently load the PDBs for DLLs loaded by the application (it could do that though).

@crosire Any sort of guidance on how one might start on this?  I've started dissecting the code a bit and think I understand the overall flow (though surely not the specifics - not nearly familiar enough with the Windows executable format for that), but I'm not totally sure where to begin in tracking changes to loaded DLL sources, especially those which are loaded at runtime (the use case I'm looking to support).

Thanks in advance!

There are two ways DLLs can be loaded, either via a static import or dynamically via `LoadLibrary`.

The first case can be covered by retrieving the PDB info here: https://github.com/crosire/blink/blob/9ca9e5c91c4cf5e23cefc7ed3c5489817ea34261/source/blink.cpp#L55
Same way it is done for the main application (get a pointer to the PE header via `GetModuleHandle` and then just locate the PDB path and read the symbol information in the same way): https://github.com/crosire/blink/blob/9ca9e5c91c4cf5e23cefc7ed3c5489817ea34261/source/blink.cpp#L92

The second case would involve hooking the `LoadLibrary` functions and doing the same thing every time a new DLL was loaded.

Has anyone tried to implement patching *.dlls loaded by main executable via static or dynamic import?

Added an untested, experimental branch which loads symbols for statically linked DLLs: ~https://github.com/crosire/blink/tree/dlls~

EDIT: This is now in master.

@crosire, thanks. I'll give it a try soon.

I have a host.exe app which loads a plugin DLL at runtime.  No access to the source code of host.exe app but only have for DLL's. Is that also possible to use blink for this case? If it is, could you let me know how to use blink for that?  Thanks in advance.

blink does not currently support dynamically loaded DLLs.

 DWARF and other platforms?
 Hi. Thank you very much for your work! Any chance to see the port of blink to use on another platforms? I'm not experienced in it, but I guess DWARF should have enough data for doing that. Are you aware of this?
Technically the concept behind blink should apply to other platforms as well. However, the implementation is currently Windows focused (on PDB files, the PE/COFF file formats and in-memory representation of executable files on Windows). Implementing it for another platform would more or less require a rewrite of everything for that platform. So it is not currently in the scope of the project.

I see, anyway thank you very much!

Hi again. Sorry for disturbing. Since you're not planning to support other platforms, could you consider placing the reference to [this](https://github.com/ddovod/jet-live) library as an alternative for linux and macos?

Sure. Thanks for implementing the concept for Unix!

As you might have guessed, your library inspired me to try this approach on non-windows, so thank you very much for inspiration!

 Use compilation command stored in obj file
 I believe full compilation command is stored in on of .debug$S sections of obj file.

```
dumpbin /section:.debug$S /rawdata main.obj

```

Excerpt from the dump:
```
SECTION HEADER #2
.debug$S name
       0 physical address
       0 virtual address
   31FC8 size of raw data
   18CFB file pointer to raw data (00018CFB to 0004ACC2)
   4ACC3 file pointer to relocation table
       0 file pointer to line numbers
      A6 number of relocations
       0 number of line numbers
42100040 flags
         Initialized Data
         Discardable
         1 byte align
         Read Only

RAW DATA #2
  00000000: 04 00 00 00 F1 00 00 00 FC 06 00 00 2E 00 01 11  ....n...ü.......
  00000010: 00 00 00 00 44 3A 5C 44 65 76 65 6C 5C 70 62 72  ....D:\Devel\pbr
  00000020: 5C 62 75 69 6C 64 5C 48 6F 74 2E 78 36 34 5C 70  \build\Hot.x64\p
  00000030: 62 72 5C 6D 61 69 6E 2E 6F 62 6A 00 3A 00 3C 11  br\main.obj.:.<.
  00000040: 01 41 00 00 D0 00 13 00 0F 00 69 68 00 00 13 00  .A..?.....ih....
  00000050: 0F 00 69 68 00 00 4D 69 63 72 6F 73 6F 66 74 20  ..ih..Microsoft 
  00000060: 28 52 29 20 4F 70 74 69 6D 69 7A 69 6E 67 20 43  (R) Optimizing C
  00000070: 6F 6D 70 69 6C 65 72 00 B1 05 3D 11 01 63 77 64  ompiler.±.=..cwd
  00000080: 00 44 3A 5C 44 65 76 65 6C 5C 70 62 72 5C 70 62  .D:\Devel\pbr\pb
  00000090: 72 00 63 6C 00 43 3A 5C 50 72 6F 67 72 61 6D 20  r.cl.C:\Program 
  000000A0: 46 69 6C 65 73 20 28 78 38 36 29 5C 4D 69 63 72  Files (x86)\Micr
  000000B0: 6F 73 6F 66 74 20 56 69 73 75 61 6C 20 53 74 75  osoft Visual Stu
  000000C0: 64 69 6F 5C 32 30 31 37 5C 43 6F 6D 6D 75 6E 69  dio\2017\Communi
  000000D0: 74 79 5C 56 43 5C 54 6F 6F 6C 73 5C 4D 53 56 43  ty\VC\Tools\MSVC
  000000E0: 5C 31 34 2E 31 35 2E 32 36 37 32 36 5C 62 69 6E  \14.15.26726\bin
  000000F0: 5C 48 6F 73 74 58 38 36 5C 78 36 34 5C 43 4C 2E  \HostX86\x64\CL.
  00000100: 65 78 65 00 63 6D 64 00 2D 63 20 2D 49 44 3A 5C  exe.cmd.-c -ID:\
  00000110: 44 65 76 65 6C 5C 70 62 72 5C 70 62 72 20 2D 49  Devel\pbr\pbr -I
  00000120: 44 3A 5C 44 65 76 65 6C 5C 70 62 72 5C 62 75 69  D:\Devel\pbr\bui
  00000130: 6C 64 5C 48 6F 74 2E 78 36 34 5C 70 62 72 5C 73  ld\Hot.x64\pbr\s
  00000140: 68 61 64 65 72 73 20 2D 49 44 3A 5C 44 65 76 65  haders -ID:\Deve
  00000150: 6C 5C 70 62 72 5C 69 6D 67 75 69 20 2D 49 44 3A  l\pbr\imgui -ID:
  00000160: 5C 44 65 76 65 6C 5C 70 62 72 5C 76 69 73 69 74  \Devel\pbr\visit
  00000170: 5F 73 74 72 75 63 74 5C 69 6E 63 6C 75 64 65 20  _struct\include 
  00000180: 2D 5A 49 20 2D 4A 4D 43 20 2D 6E 6F 6C 6F 67 6F  -ZI -JMC -nologo
  00000190: 20 2D 57 33 20 2D 57 58 2D 20 2D 64 69 61 67 6E   -W3 -WX- -diagn
  000001A0: 6F 73 74 69 63 73 3A 63 6C 61 73 73 69 63 20 2D  ostics:classic -
  000001B0: 73 64 6C 2D 20 2D 4D 50 20 2D 4F 64 20 2D 44 5F  sdl- -MP -Od -D_
  000001C0: 44 45 42 55 47 20 2D 44 5F 57 49 4E 44 4F 57 53  DEBUG -D_WINDOWS
  000001D0: 20 2D 44 5F 57 49 4E 33 32 5F 57 49 4E 4E 54 3D   -D_WIN32_WINNT=
  000001E0: 30 78 30 36 30 30 20 2D 44 57 49 4E 33 32 20 2D  0x0600 -DWIN32 -
  000001F0: 44 5F 55 4E 49 43 4F 44 45 20 2D 44 55 4E 49 43  D_UNICODE -DUNIC
  00000200: 4F 44 45 20 2D 47 46 20 2D 47 6D 2D 20 2D 45 48  ODE -GF -Gm- -EH
  00000210: 73 20 2D 45 48 63 20 2D 52 54 43 31 20 2D 4D 44  s -EHc -RTC1 -MD
  00000220: 64 20 2D 47 53 2D 20 2D 66 70 3A 70 72 65 63 69  d -GS- -fp:preci
  00000230: 73 65 20 2D 70 65 72 6D 69 73 73 69 76 65 2D 20  se -permissive- 
  00000240: 2D 5A 63 3A 77 63 68 61 72 5F 74 20 2D 5A 63 3A  -Zc:wchar_t -Zc:
  00000250: 66 6F 72 53 63 6F 70 65 20 2D 5A 63 3A 69 6E 6C  forScope -Zc:inl
  00000260: 69 6E 65 20 2D 73 74 64 3A 63 2B 2B 31 37 20 2D  ine -std:c++17 -
  00000270: 46 6F 44 3A 5C 44 65 76 65 6C 5C 70 62 72 5C 62  FoD:\Devel\pbr\b
  00000280: 75 69 6C 64 5C 48 6F 74 2E 78 36 34 5C 70 62 72  uild\Hot.x64\pbr
  00000290: 5C 20 2D 46 64 44 3A 5C 44 65 76 65 6C 5C 70 62  \ -FdD:\Devel\pb
  000002A0: 72 5C 62 75 69 6C 64 5C 48 6F 74 2E 78 36 34 5C  r\build\Hot.x64\
  000002B0: 70 62 72 5C 76 63 31 34 31 2E 70 64 62 20 2D 47  pbr\vc141.pdb -G
  000002C0: 64 20 2D 54 50 20 2D 46 43 20 2D 65 72 72 6F 72  d -TP -FC -error
  000002D0: 72 65 70 6F 72 74 3A 70 72 6F 6D 70 74 20 2D 49  report:prompt -I
  000002E0: 22 43 3A 5C 50 72 6F 67 72 61 6D 20 46 69 6C 65  "C:\Program File
  000002F0: 73 20 28 78 38 36 29 5C 4D 69 63 72 6F 73 6F 66  s (x86)\Microsof
  00000300: 74 20 56 69 73 75 61 6C 20 53 74 75 64 69 6F 5C  t Visual Studio\
  00000310: 32 30 31 37 5C 43 6F 6D 6D 75 6E 69 74 79 5C 56  2017\Community\V
  00000320: 43 5C 54 6F 6F 6C 73 5C 4D 53 56 43 5C 31 34 2E  C\Tools\MSVC\14.
  00000330: 31 35 2E 32 36 37 32 36 5C 69 6E 63 6C 75 64 65  15.26726\include
  00000340: 22 20 2D 49 22 43 3A 5C 50 72 6F 67 72 61 6D 20  " -I"C:\Program 
  00000350: 46 69 6C 65 73 20 28 78 38 36 29 5C 4D 69 63 72  Files (x86)\Micr
  00000360: 6F 73 6F 66 74 20 56 69 73 75 61 6C 20 53 74 75  osoft Visual Stu
  00000370: 64 69 6F 5C 32 30 31 37 5C 43 6F 6D 6D 75 6E 69  dio\2017\Communi
  00000380: 74 79 5C 56 43 5C 54 6F 6F 6C 73 5C 4D 53 56 43  ty\VC\Tools\MSVC
  00000390: 5C 31 34 2E 31 35 2E 32 36 37 32 36 5C 61 74 6C  \14.15.26726\atl
  000003A0: 6D 66 63 5C 69 6E 63 6C 75 64 65 22 20 2D 49 22  mfc\include" -I"
  000003B0: 43 3A 5C 50 72 6F 67 72 61 6D 20 46 69 6C 65 73  C:\Program Files
  000003C0: 20 28 78 38 36 29 5C 4D 69 63 72 6F 73 6F 66 74   (x86)\Microsoft
  000003D0: 20 56 69 73 75 61 6C 20 53 74 75 64 69 6F 5C 32   Visual Studio\2
  000003E0: 30 31 37 5C 43 6F 6D 6D 75 6E 69 74 79 5C 56 43  017\Community\VC
  000003F0: 5C 41 75 78 69 6C 69 61 72 79 5C 56 53 5C 69 6E  \Auxiliary\VS\in
  00000400: 63 6C 75 64 65 22 20 2D 49 22 43 3A 5C 50 72 6F  clude" -I"C:\Pro
  00000410: 67 72 61 6D 20 46 69 6C 65 73 20 28 78 38 36 29  gram Files (x86)
  00000420: 5C 57 69 6E 64 6F 77 73 20 4B 69 74 73 5C 31 30  \Windows Kits\10
  00000430: 5C 49 6E 63 6C 75 64 65 5C 31 30 2E 30 2E 31 37  \Include\10.0.17
  00000440: 37 36 33 2E 30 5C 75 63 72 74 22 20 2D 49 22 43  763.0\ucrt" -I"C
  00000450: 3A 5C 50 72 6F 67 72 61 6D 20 46 69 6C 65 73 20  :\Program Files 
  00000460: 28 78 38 36 29 5C 57 69 6E 64 6F 77 73 20 4B 69  (x86)\Windows Ki
  00000470: 74 73 5C 31 30 5C 49 6E 63 6C 75 64 65 5C 31 30  ts\10\Include\10
  00000480: 2E 30 2E 31 37 37 36 33 2E 30 5C 75 6D 22 20 2D  .0.17763.0\um" -
  00000490: 49 22 43 3A 5C 50 72 6F 67 72 61 6D 20 46 69 6C  I"C:\Program Fil
  000004A0: 65 73 20 28 78 38 36 29 5C 57 69 6E 64 6F 77 73  es (x86)\Windows
  000004B0: 20 4B 69 74 73 5C 31 30 5C 49 6E 63 6C 75 64 65   Kits\10\Include
  000004C0: 5C 31 30 2E 30 2E 31 37 37 36 33 2E 30 5C 73 68  \10.0.17763.0\sh
  000004D0: 61 72 65 64 22 20 2D 49 22 43 3A 5C 50 72 6F 67  ared" -I"C:\Prog
  000004E0: 72 61 6D 20 46 69 6C 65 73 20 28 78 38 36 29 5C  ram Files (x86)\
  000004F0: 57 69 6E 64 6F 77 73 20 4B 69 74 73 5C 31 30 5C  Windows Kits\10\
  00000500: 49 6E 63 6C 75 64 65 5C 31 30 2E 30 2E 31 37 37  Include\10.0.177
  00000510: 36 33 2E 30 5C 77 69 6E 72 74 22 20 2D 49 22 43  63.0\winrt" -I"C
  00000520: 3A 5C 50 72 6F 67 72 61 6D 20 46 69 6C 65 73 20  :\Program Files 
  00000530: 28 78 38 36 29 5C 57 69 6E 64 6F 77 73 20 4B 69  (x86)\Windows Ki
  00000540: 74 73 5C 31 30 5C 49 6E 63 6C 75 64 65 5C 31 30  ts\10\Include\10
  00000550: 2E 30 2E 31 37 37 36 33 2E 30 5C 63 70 70 77 69  .0.17763.0\cppwi
  00000560: 6E 72 74 22 20 2D 49 22 43 3A 5C 50 72 6F 67 72  nrt" -I"C:\Progr
  00000570: 61 6D 20 46 69 6C 65 73 20 28 78 38 36 29 5C 57  am Files (x86)\W
  00000580: 69 6E 64 6F 77 73 20 4B 69 74 73 5C 4E 45 54 46  indows Kits\NETF
  00000590: 58 53 44 4B 5C 34 2E 36 2E 31 5C 49 6E 63 6C 75  XSDK\4.6.1\Inclu
  000005A0: 64 65 5C 75 6D 22 20 2D 49 22 43 3A 5C 50 72 6F  de\um" -I"C:\Pro
  000005B0: 67 72 61 6D 20 46 69 6C 65 73 20 28 78 38 36 29  gram Files (x86)
  000005C0: 5C 57 69 6E 64 6F 77 73 20 4B 69 74 73 5C 4E 45  \Windows Kits\NE
  000005D0: 54 46 58 53 44 4B 5C 34 2E 36 2E 31 5C 49 6E 63  TFXSDK\4.6.1\Inc
  000005E0: 6C 75 64 65 5C 75 6D 22 20 2D 58 00 73 72 63 00  lude\um" -X.src.
  000005F0: 61 70 70 5C 6D 61 69 6E 2E 63 70 70 00 70 64 62  app\main.cpp.pdb
  00000600: 00 44 3A 5C 44 65 76 65 6C 5C 70 62 72 5C 62 75  .D:\Devel\pbr\bu
  00000610: 69 6C 64 5C 48 6F 74 2E 78 36 34 5C 70 62 72 5C  ild\Hot.x64\pbr\
  00000620: 76 63 31 34 31 2E 70 64 62 00 00 09 00 24 11 6C  vc141.pdb....$.l
  00000630: 6F 67 67 65 72 00 09 00 24 11 69 6D 70 6F 72 74  ogger...$.import
  00000640: 00 0C 00 24 11 4D 69 63 72 6F 73 6F 66 74 00 06  ...$.Microsoft..
  00000650: 00 24 11 57 52 4C 00 0A 00 24 11 44 65 74 61 69  .$.WRL...$.Detai
...

```

This command could be used to recompile modified source files. Right now compilation command has to be hardcoded in the blink.exe.
Ah, so it is still there after all. Yeah, I did that previously (it's still in the commit log somewhere), but removed it since that information did no longer exist in the PDBs of projects I compiled with Visual C++ 2017 and thus I had though Microsoft removed it. But it could be that you need to enable the "Edit & Continue" PDB format for that information to appear in the PDB.

I'm on "Edit & Continue" PDB (/ZI) and cannot find any compilation command neither with hexviewer nor with cvdump. There is only a linker command present.

Nevermind, I misread your post. You were talking about the OBJ file, not PDB. That's less usefull though, since there is no way to obtain this information from the application? Unless paths to the OBJ files are stored in the PDB, but if I recall correctly that is not the case.

OBJ files are listed in the PDB as modules.


```
Microsoft (R) Debugging Information Dumper  Version 14.00.23611
Copyright (C) Microsoft Corporation.  All rights reserved.


*** IDs


*** MODULES

0001 "D:\Devel\pbr\build\Hot.x64\pbr\pbr.res"
0002 "D:\Devel\pbr\build\Hot.x64\pbr\tangent.obj"
0003 "D:\Devel\pbr\build\Hot.x64\pbr\mikktspace.obj"
0004 "D:\Devel\pbr\build\Hot.x64\pbr\import_obj.obj"
0005 "D:\Devel\pbr\build\Hot.x64\pbr\import.obj"
0006 "D:\Devel\pbr\build\Hot.x64\pbr\gui.obj"
0007 "D:\Devel\pbr\build\Hot.x64\pbr\tick.obj"
0008 "D:\Devel\pbr\build\Hot.x64\pbr\input_win.obj"
0009 "D:\Devel\pbr\build\Hot.x64\pbr\input.obj"
000A "D:\Devel\pbr\build\Hot.x64\pbr\states11.obj"
000B "D:\Devel\pbr\build\Hot.x64\pbr\scene11.obj"
000C "D:\Devel\pbr\build\Hot.x64\pbr\render11.obj"
000D "D:\Devel\pbr\build\Hot.x64\pbr\import11.obj"
000E "D:\Devel\pbr\build\Hot.x64\pbr\device11.obj"
000F "D:\Devel\pbr\build\Hot.x64\pbr\transform.obj"
0010 "D:\Devel\pbr\build\Hot.x64\pbr\log.obj"
0011 "D:\Devel\pbr\build\Hot.x64\pbr\hresult.obj"
0012 "D:\Devel\pbr\build\Hot.x64\pbr\file.obj"
0013 "D:\Devel\pbr\build\Hot.x64\pbr\allocator.obj"
0014 "D:\Devel\pbr\build\Hot.x64\pbr\main.obj"
0015 "D:\Devel\pbr\build\Hot.x64\pbr\imgui_widgets.obj"
0016 "D:\Devel\pbr\build\Hot.x64\pbr\imgui_draw.obj"
0017 "D:\Devel\pbr\build\Hot.x64\pbr\imgui.obj"
0018 "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\d3d11.lib" "Import:d3d11.dll"
0019 "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\d3d11.lib" "d3d11.dll"
001A "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\dxgi.lib" "Import:dxgi.dll"
001B "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\dxgi.lib" "dxgi.dll"
001C "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\dxguid.lib" "d:\os\obj\amd64fre\onecoreuap\windows\directx\misc\dxguid\daytona\objfre\amd64\d3d10guid.obj"
001D "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\ws2_32.lib" "Import:WS2_32.dll"
001E "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\ws2_32.lib" "WS2_32.dll"
001F "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\kernel32.lib" "Import:KERNEL32.dll"
0020 "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\kernel32.lib" "KERNEL32.dll"
0021 "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\user32.lib" "Import:USER32.dll"
0022 "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\user32.lib" "USER32.dll"
0023 "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\imm32.lib" "Import:IMM32.dll"
0024 "C:\Program Files (x86)\Windows Kits\10\lib\10.0.17763.0\um\x64\imm32.lib" "IMM32.dll"
…
```

List of compilands (OBJ files) can be obtained with DIA https://gist.github.com/optimizedaway/5a2c2b5a9284e6a2e55ff0dd1badf083

Nice! Well in that case, this is doable. I want to avoid dependencies and DIA, but can extend the PDB parser to read that information easily (it's in the DBI stream, right after the DBI header).
https://github.com/crosire/blink/blob/2ced27abd536dcae884413a321f9ced072c27ffb/source/pdb_reader.cpp#L217

Great! avoid DIA if you can, although with NoRegCoCreate at least you avoid COM hell. I'm available should you need any help.

This works now 
First of all, Thank you fo blink. It is amazing :)

As you already know, blink is not able to extract the compilation command when compiling with /Z7.
 (in that case compilation command is not stored in .debug$S section).
I use fastbuild (https://github.com/fastbuild/fastbuild ) and distributed compilation is problematic without Z7.
After investigating the contents of an OBJ file compiled with Z7 I noticed that compilation command seems to be stored in .debug$T instead of .debug$S...

 File watcher should watch subdirectories
 File watcher only scans for changes in the root directory, subdirectories should also be watched.
It does actually watch subdirectories:
https://github.com/crosire/blink/blob/7a82c5017fcb8e2cb222261f85b7899983374980/source/file_watcher.cpp#L60 The `bWatchSubtree` parameter of `ReadDirectoryChangesW` is set to `TRUE`. It is working on my end.

Yup, my fault, sorry

 File watcher starts for the first file
 File watcher should be started for the common root path (d:\devel\pbr in this case), but starts for the first file (d:\devel\pbr\pbr\import\tangent.cpp). Non-existing files added by the linker should be ignored (onecoreuap\windows\directx\misc\dxguid\d3d10guid.cpp)
```
Reading PE debug info directory ...
  Found program debug database: D:\Devel\pbr\bin\Hot.x64\pbr.pdb
  Found source file: d:\devel\pbr\pbr\import\tangent.cpp
  Found source file: d:\devel\pbr\pbr\import\import_obj.cpp
  Found source file: d:\devel\pbr\pbr\import\import.cpp
  Found source file: d:\devel\pbr\pbr\gui\gui.cpp
  Found source file: d:\devel\pbr\pbr\event\tick.cpp
  Found source file: d:\devel\pbr\pbr\event\input_win.cpp
  Found source file: d:\devel\pbr\pbr\event\input.cpp
